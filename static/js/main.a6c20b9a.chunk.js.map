{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["ANSI_UP","AnsiUp","testUrl","c","name","matches","match","ref","use_classes","TestFailure","test","cref","stdout","html","ansi_to_html","lines","split","filter","line","length","map","replace","join","p","fontSize","id","className","href","icon","OLink","dangerouslySetInnerHTML","__html","Render","single","ok","failed","ignored","failedKeys","Object","keys","sort","failedOut","key","mb","S3_PREFIX","path","a","fetch","res","text","events","x","eventJSON","JSON","parse","summary","test_names","event","type","FetchAndRender","commitRef","useState","setSingle","error","setError","useEffect","fetchSingle","then","catch","e","toString","Nav","to","as","Branch","props","m","branch","Commit","commit","App","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.a6c20b9a.chunk.js","sourcesContent":["import React from 'react';\nimport { Router, Link, RouteComponentProps } from \"@reach/router\"\nimport './App.css';\nimport { BaseStyles, CounterLabel, Box, Heading, BorderBox, BranchName, Flex, StyledOcticon } from '@primer/components'\nimport { Text } from '@primer/components'\nimport { default as AnsiUp } from 'ansi_up';\nimport { useState, useEffect } from 'react';\nimport { Link as OLink } from '@primer/octicons-react';\n\nconst ANSI_UP = new AnsiUp();\nANSI_UP.use_classes = false;\n\ninterface Test {\n    event: string;\n    name: string;\n    stdout: string | null;\n}\n\ntype TestEvent = Test & { type: \"suite\" | \"test\" };\n\ninterface TestSummary {\n    test_names: string[];\n    ok: { [k: string]: Test },\n    failed: { [k: string]: Test },\n    ignored: { [k: string]: Test },\n}\n\nfunction testUrl(c: CommitRef, name: string) {\n    let matches = name.match(/::(.+.txt)$/);\n    if (matches) {\n        return `https://github.com/cormacrelf/test-suite/tree/master/processor-tests/humans/${matches[1]}`;\n    }\n    matches = name.match(/::(.+.ya?ml)$/);\n    if (matches) {\n        return `https://github.com/cormacrelf/citeproc-rs/tree/${c.ref}/crates/citeproc/tests/data/humans/${matches[1]}`;\n    }\n}\n\nconst TestFailure = ({ test, cref }: { test: Test, cref: CommitRef }) => {\n    let stdout = test.stdout;\n    let html = \"\";\n    if (stdout != null) {\n        html = ANSI_UP.ansi_to_html(stdout);\n    }\n    let lines = html.split(\"\\n\").filter(line => {\n        let match  = line.match(/assertion failed: `\\(left == right\\)`/)\n            || line.match(\"RUST_BACKTRACE=1\")\n            || line.match(\"<span style=\\\"font-weight:bold\\\">Diff</span>\")\n            || line.match(\"crates/citeproc/tests/suite.rs\");\n        let matches = line.length === 0 || (match && match.length > 0);\n        return !matches;\n    })\n        .map(line => line\n            .replace('<span style=\"color:rgb(187,0,0)\">&lt;</span>', '<span style=\"color:rgb(187,0,0)\">-</span>')\n            .replace('<span style=\"color:rgb(0,187,0)\">&gt;</span>', '<span style=\"color:rgb(0,187,0)\">+</span>')\n            .replace(/rgb\\(0,95,0\\)/g, \"#cdffd8\")\n            .replace(/rgb\\(95,0,0\\)/g, \"#ffdce0\")\n        )\n        .join(\"\\n\");\n    return <BorderBox p={4}>\n        <Heading fontSize={2} id={test.name}>\n            <a className=\"anchor\" href={testUrl(cref, test.name)}>\n                <StyledOcticon icon={OLink} />\n            </a>\n            {\" \"} { test.name }\n        </Heading>\n        <Box className=\"stdout\">\n            <pre><code dangerouslySetInnerHTML={{__html: lines}}></code></pre>\n        </Box>\n     </BorderBox>;\n};\n\nconst Render = ({ single, cref }: { single: TestSummary, cref: CommitRef }) => {\n    let { ok, failed, ignored } = single;\n    let failedKeys = Object.keys(failed).sort();\n    let failedOut = failedKeys.map(key => {\n        let test = failed[key];\n        return <TestFailure key={test.name} test={test} cref={cref} />\n    })\n    return <Box>\n        <Box mb={4}>\n            <Text><CounterLabel>{ Object.keys(ok).length }</CounterLabel> ok, <CounterLabel>{ failedKeys.length }</CounterLabel> failed, <CounterLabel>{ Object.keys(ignored).length }</CounterLabel> ignored</Text>\n        </Box>\n        { failedOut }\n    </Box>;\n}\n\nlet S3_PREFIX = \"http://citeproc-rs-test-results.s3-website-ap-southeast-2.amazonaws.com/\";\nasync function fetchSingle(path: string) {\n    let res = await fetch(S3_PREFIX + \".snapshots/\" + path);\n    let text = await res.text();\n    let events = text.split(\"\\n\").filter(x => x.length > 0).map(eventJSON => JSON.parse(eventJSON)) as TestEvent[];\n    let summary = {\n        test_names: [],\n        ok: {},\n        failed: {},\n        ignored: {}\n    } as TestSummary;\n    for (let event of events) {\n        if (event.type === \"test\") {\n            if (event.event === \"failed\") {\n                summary.failed[event.name] = event;\n            } else if (event.event === \"ignored\") {\n                summary.ignored[event.name] = event;\n            } else if (event.event === \"ok\") {\n                summary.ok[event.name] = event;\n            }\n        }\n    }\n    return summary;\n}\n\ntype CommitRef = { type: \"commits\", ref: string } | { type: \"branches\", ref: string };\n\nconst FetchAndRender = ({ commitRef }: { commitRef: CommitRef }) => {\n    const [single, setSingle] = useState<TestSummary>();\n    const [error, setError] = useState(false);\n\n    useEffect(() => {\n        fetchSingle(commitRef.type + \"/\" + commitRef.ref)\n            .then(setSingle)\n            .catch(e => {\n                setError(e);\n            });\n    }, [commitRef.ref, commitRef.type]);\n\n    if (error) {\n        return <Text>Error loading { commitRef.ref }: <pre><code>{ error.toString() }</code></pre></Text>\n    }\n    if (!single) {\n        return <Text>Loading...</Text>\n    }\n    return <Box>\n        <Heading>\n            <BranchName className=\"branch-heading\" href={\"https://github.com/cormacrelf/citeproc-rs/tree/\" + commitRef.ref}>{ commitRef.ref }</BranchName>\n                <br />\n            citeproc-rs test results \n        </Heading>\n        <Render single={single} cref={commitRef} />\n    </Box>;\n};\n\ntype Routed<T> = RouteComponentProps & Partial<T>;\n// </T>\n\nconst Nav = () => {\n    return <Flex>\n        <Link to=\"/\" ><BranchName as=\"span\">master</BranchName></Link>\n    </Flex>;\n}\n\nconst Branch = (props: Routed<{ branch: string }>) => {\n    return <Box m={4} p={4}>\n        { props.branch ? <FetchAndRender commitRef={{ type: \"branches\", ref: props.branch }} /> : null }\n    </Box>\n};\n\nconst Commit = (props: Routed<{ commit: string }>) => {\n    return <Box m={4} p={4}>\n        { props.commit ? <FetchAndRender commitRef={{ type: \"commits\", ref: props.commit }} /> : null }\n    </Box>\n};\n\nconst App: React.FC = () => {\n    return (\n        <BaseStyles>\n            <Nav />\n            <Router>\n                <Branch path=\"/\" branch=\"master\" />\n                <Branch path=\"/branches/:branch\" />\n                <Commit path=\"/commits/:commit\" />\n            </Router>\n        </BaseStyles>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}