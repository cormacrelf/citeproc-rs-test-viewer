{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["ANSI_UP","AnsiUp","testUrl","c","name","matches","match","ref","use_classes","TestFailure","test","cref","stdout","html","ansi_to_html","lines","split","filter","line","length","map","replace","join","p","fontSize","id","className","href","icon","OLink","dangerouslySetInnerHTML","__html","Render","single","useState","setFilter","ok","failed","ignored","failedKeys","useMemo","Object","keys","sort","prefixes","hash","split0","filter_","filtered","key","indexOf","prefixFilters","prefix","Item","selected","count","onClick","failedOut","undefined","mb","minWidth","pr","pt","small","S3_PREFIX","path","a","fetch","res","text","events","x","eventJSON","JSON","parse","summary","test_names","event","type","FetchAndRender","commitRef","setSingle","error","setError","useEffect","fetchSingle","then","catch","e","toString","Nav","to","as","Master","m","Branch","branch","useParams","Commit","commit","App","basename","process","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.2c878c2f.chunk.js","sourcesContent":["import React, {useMemo} from 'react';\nimport {\n    BrowserRouter as Router,\n    Switch,\n    Route,\n    Link,\n    useParams,\n} from \"react-router-dom\";\nimport './App.css';\nimport { BaseStyles, CounterLabel, Box, Heading, BorderBox, BranchName, Flex, StyledOcticon, FilterList, Button } from '@primer/components'\nimport { Text } from '@primer/components'\nimport { default as AnsiUp } from 'ansi_up';\nimport { useState, useEffect } from 'react';\nimport { Link as OLink } from '@primer/octicons-react';\n\nconst ANSI_UP = new AnsiUp();\nANSI_UP.use_classes = false;\n\ninterface Test {\n    event: string;\n    name: string;\n    stdout: string | null;\n}\n\ntype TestEvent = Test & { type: \"suite\" | \"test\" };\n\ninterface TestSummary {\n    test_names: string[];\n    ok: { [k: string]: Test },\n    failed: { [k: string]: Test },\n    ignored: { [k: string]: Test },\n}\n\nfunction testUrl(c: CommitRef, name: string) {\n    let matches = name.match(/::(.+.txt)$/);\n    if (matches) {\n        return `https://github.com/cormacrelf/test-suite/tree/master/processor-tests/humans/${matches[1]}`;\n    }\n    matches = name.match(/::(.+.ya?ml)$/);\n    if (matches) {\n        return `https://github.com/cormacrelf/citeproc-rs/tree/${c.ref}/crates/citeproc/tests/data/humans/${matches[1]}`;\n    }\n}\n\nconst TestFailure = ({ test, cref }: { test: Test, cref: CommitRef }) => {\n    let stdout = test.stdout;\n    let html = \"\";\n    if (stdout != null) {\n        html = ANSI_UP.ansi_to_html(stdout);\n    }\n    let lines = html.split(\"\\n\").filter(line => {\n        let match  = line.match(/assertion failed: `\\(left == right\\)`/)\n            || line.match(\"RUST_BACKTRACE=1\")\n            || line.match(\"<span style=\\\"font-weight:bold\\\">Diff</span>\")\n            || line.match(\"crates/citeproc/tests/suite.rs\");\n        let matches = line.length === 0 || (match && match.length > 0);\n        return !matches;\n    })\n        .map(line => line\n            .replace('<span style=\"color:rgb(187,0,0)\">&lt;</span>', '<span style=\"color:rgb(187,0,0)\">-</span>')\n            .replace('<span style=\"color:rgb(0,187,0)\">&gt;</span>', '<span style=\"color:rgb(0,187,0)\">+</span>')\n            .replace(/rgb\\(0,95,0\\)/g, \"#cdffd8\")\n            .replace(/rgb\\(95,0,0\\)/g, \"#ffdce0\")\n        )\n        .join(\"\\n\");\n    return <BorderBox p={4}>\n        <Heading fontSize={2} id={test.name}>\n            <a className=\"anchor\" href={testUrl(cref, test.name)}>\n                <StyledOcticon icon={OLink} />\n            </a>\n            {\" \"} { test.name }\n        </Heading>\n        <Box className=\"stdout\">\n            <pre><code dangerouslySetInnerHTML={{__html: lines}}></code></pre>\n        </Box>\n     </BorderBox>;\n};\n\nconst Render = ({ single, cref }: { single: TestSummary, cref: CommitRef }) => {\n    const [filter, setFilter] = useState<string | null>(null);\n    let { ok, failed, ignored } = single;\n    let failedKeys = useMemo(() => Object.keys(failed).sort(), [failed]);\n    let prefixes = useMemo(() => {\n        let hash = {} as { [k: string]: number };\n        for (let key of failedKeys) {\n            let split0 = key.split(\"::\");\n            if (split0.length > 1) {\n                let name = split0[1];\n                let split = name.split(\"_\");\n                if (split.length > 0) {\n                    hash[split[0]] = (hash[split[0]] || 0) + 1;\n                }\n            }\n        }\n        return hash;\n    }, [failedKeys]);\n    let filter_ = \"::\" + filter + \"_\";\n    let filtered = useMemo(() => {\n        if (filter !== null) {\n            let hash = {} as { [k: string]: boolean };\n            for (let key of failedKeys) {\n                if (key.indexOf(filter_) === -1) {\n                    hash[key] = true;\n                }\n            }\n            return hash\n        } else {\n            return {};\n        }\n    }, [failedKeys, filter, filter_])\n\n    let prefixFilters = Object.keys(prefixes).map(prefix => {\n        return <FilterList.Item selected={prefix===filter} count={prefixes[prefix]} onClick={() => setFilter(prefix)}>{ prefix }</FilterList.Item>\n    })\n    let failedOut = failedKeys\n        .map(key => {\n            let test = failed[key];\n            return <div className={filtered[test.name] ? \"hidden\" : undefined} key={test.name} >\n                <TestFailure test={test} cref={cref} />\n            </div>;\n        });\n    return (\n        <>\n            <Box>\n                <Text><CounterLabel>{ Object.keys(ok).length }</CounterLabel> ok, <CounterLabel>{ failedKeys.length }</CounterLabel> failed, <CounterLabel>{ Object.keys(ignored).length }</CounterLabel> ignored</Text>\n                { filter !== null && \n                  <Button onClick={() => setFilter(null)}>Clear filters</Button> }\n            </Box>\n            <Flex mb={4}>\n                <Box minWidth='220px' pr={4} pt={4}>\n                    <FilterList small={true}>\n                        {prefixFilters}\n                    </FilterList>\n                </Box>\n                <Box pt={4}>\n                { failedOut }\n                </Box>\n            </Flex>\n        </>\n    );\n}\n\nlet S3_PREFIX = \"https://citeproc-rs-test-results.cormacrelf.net/.snapshots/\";\nasync function fetchSingle(path: string) {\n    let res = await fetch(S3_PREFIX + path);\n    let text = await res.text();\n    let events = text.split(\"\\n\").filter(x => x.length > 0).map(eventJSON => JSON.parse(eventJSON)) as TestEvent[];\n    let summary = {\n        test_names: [],\n        ok: {},\n        failed: {},\n        ignored: {}\n    } as TestSummary;\n    for (let event of events) {\n        if (event.type === \"test\") {\n            if (event.event === \"failed\") {\n                summary.failed[event.name] = event;\n            } else if (event.event === \"ignored\") {\n                summary.ignored[event.name] = event;\n            } else if (event.event === \"ok\") {\n                summary.ok[event.name] = event;\n            }\n        }\n    }\n    return summary;\n}\n\ntype CommitRef = { type: \"commits\", ref: string } | { type: \"branches\", ref: string };\n\nconst FetchAndRender = ({ commitRef }: { commitRef: CommitRef }) => {\n    const [single, setSingle] = useState<TestSummary>();\n    const [error, setError] = useState(false);\n\n    useEffect(() => {\n        fetchSingle(commitRef.type + \"/\" + commitRef.ref)\n            .then(setSingle)\n            .catch(e => {\n                setError(e);\n            });\n    }, [commitRef.ref, commitRef.type]);\n\n    if (error) {\n        return <Text>Error loading { commitRef.ref }: <pre><code>{ error.toString() }</code></pre></Text>\n    }\n    if (!single) {\n        return <Text>Loading...</Text>\n    }\n    return <Box>\n        <Heading>\n            <BranchName className=\"branch-heading\" href={\"https://github.com/cormacrelf/citeproc-rs/tree/\" + commitRef.ref}>{ commitRef.ref }</BranchName>\n                <br />\n            citeproc-rs test results \n        </Heading>\n        <Render single={single} cref={commitRef} />\n    </Box>;\n};\n\nconst Nav = () => {\n    return <Flex>\n        <Link to=\"/\" ><BranchName as=\"span\">master</BranchName></Link>\n    </Flex>;\n}\n\nconst Master = () => {\n    const branch = \"master\";\n    return <Box m={4} p={4}>\n        { branch ? <FetchAndRender commitRef={{ type: \"branches\", ref: branch }} /> : null }\n    </Box>\n};\n\nconst Branch = () => {\n    const { branch } = useParams();\n    return <Box m={4} p={4}>\n        { branch ? <FetchAndRender commitRef={{ type: \"branches\", ref: branch }} /> : null }\n    </Box>\n};\n\nconst Commit = () => {\n    const { commit } = useParams();\n    return <Box m={4} p={4}>\n        { commit ? <FetchAndRender commitRef={{ type: \"commits\", ref: commit }} /> : null }\n    </Box>\n};\n\nconst App: React.FC = () => {\n    return (\n        <BaseStyles>\n            <Router basename={process.env.PUBLIC_URL}>\n                <Nav />\n                <Switch>\n                    <Route path=\"/\">\n                        <Master />\n                    </Route>\n                    <Route path=\"/branches/:branch\">\n                        <Branch/>\n                    </Route>\n                    <Route path=\"/commits/:commit\">\n                        <Commit/>\n                    </Route>\n                    <Route>\n                        {\"Route not found\"}\n                    </Route>\n                </Switch>\n            </Router>\n        </BaseStyles>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}